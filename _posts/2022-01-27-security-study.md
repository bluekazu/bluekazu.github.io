---
layout: post
title: "보안의 기본"
---
# 암호
- 암호 알고리즘 + 키
- 공통키 암호 (symmetric 대칭키 암호)
  - 암호화 키 == 복호화 키
  - 공통키를 공유하기 위해, 공통키를 암호화할 필요가 있음 (키 배송 문제)
    - 공통키를 암호화하기 위해 공개키 암호 방식 등을 사용
  - 키의 길이가 보안의 강도
  - 속도의 이점
  - DES (Data Encryption Standard)
  - AES (Advanced Encryption Standard)
- 공개키 암호 (asymmetric 비대칭키 암호)
  - 암호화 키 (공개키) != 복호화 키 (비밀키)
  - 수신측 (복호화측)에서 공개키를 송신측 (암호화측)에 전달하고, 송신측 (암호화측)에서 공개키로 암호화하여 전달하면, 수신측 (복호화측)에서 비밀키로 복호화
  - 계산량이 많다는 단점

# HASH
- 해시 알고리즘
- 데이터가 변조되지 않았음을 나타내기 위해
- MD5 / SHA

# 전자서명
- 키 생성 알고리즘 + 서명 알고리즘 + 검증 알고리즘
- 전자 데이터가 변조되지 않았음을 나타내기 위해
- 키 생성 알고리즘
  - 서명키 (비밀키) + 검증키 (공개키)
- 서명 알고리즘
  - 서명키 (비밀키)를 이용하여 전자 데이터로부터 서명 데이터를 생성
    - 전자 데이터를 해싱한 다음, 해시값(A)을 비밀키로 서명하여 서명 데이터 생성
- 검증 알고리즘
  - 검증키 (공개키)를 이용하여 서명 데이터를 검증
  - 서명 데이터를 공개키로 복호화 => 해시값(A) 획득
  - 전자 데이터를 해싱 => 해시값(B) 획득
  - 해시값(A) 와 해시값(B) 가 동일한지 검증
- RSA / ElGamal / DSA

# 인증서
- 발행자 + 발행받는 자 + 유효기간 + ......
- 자신이 올바른 존재임을 나타내기 위한 장치
- 서버의 존재 증명
- 암호화 통신 수행하기 위한 신뢰의 기초
- 전자 서명을 하는 경우 인증서를 사용하는 경우도 있음
- 인증국 (CA : Certificate Authority)
- 공개키 기반 (PKI : Public Key Infrastructure)
- 서버 인증서를 검증하기 위해서, 서버 인증서를 발행한 인증국의 인증서 필요 (root 인증서 혹은 중간 인증서)
- root 인증서는 OS / 브라우저 와 함께 배포됨
- 중간 인증서는 서버 인증서와 함께 서버에 저장됨
- 인증서 폐기 목록 (CRL : Certificate Revocation List)
- 서버 인증서를 root 인증국이 발행하는 경우
  - 이용자가 서버에게 서버 인증서를 요구하고, 서버 인증서를 제시 받음
    - 서버 인증서는 root 인증국의 비밀키로 서명 되어 있음
  - root 인증서 - 서버 인증서
    - 이용자가 root 인증서에서 공개키를 추출
    - 서버 인증서를 root 인증서의 공개키로 검증
- 서버 인증서를 중간 인증국이 발행하는 경우
  - 이용자가 서버에게 서버 인증서를 요구하고, 서버 인증서 및 중간 인증서를 제시 받음
    - 중간 인증서는 root 인증국의 비밀키로 서명 되어 있음
    - 서버 인증서는 중간 인증국의 비밀키로 서명 되어 있음
  - 중간 인증서 - 서버 인증서
    - 이용자가 중간 인증서에서 공개키를 추출
    - 서버 인증서를 중간 인증서의 공개키로 검증
  - root 인증서 - 중간 인증서
    - 이용자가 root 인증서에서 공개키를 추출
    - 중간 인증서를 root 인증서의 공개키로 검증

# TLS
- SSL (Secure Sockets Layer) => TLS (Transport Layer Security)
- 인터넷 통신을 할 때의 인증(Handshake protocol) 및 통신 암호화 장치
- OpenSSL : SSL/TLS 의 오픈소스 구현 (Heartbleed 라는 취약성이 발견되었었음)
- mbed TLS : SSL/TLS 및 필요한 암호화 알고리즘 및 지원 코드의 구현
- Handshake protocol
  - c => s : xxx 라는 알고리즘을 사용할 수 있다
  - s => c : xxx 로 합시다
  - s => c : 인증서 (공개키) 를 보낸다
  - c : 인증서 검증 / 프리 마스터 키 (랜덤으로 생성되는 숫자) 생성
  - c => s : 프리 마스터 키를 서버의 공개키로 암호화해서 보냄
  - s : 프리 마스터 키를 비밀키로 복호화
  - c & s : 프리 마스터 키를 사용하여 암호화에 필요한 공통키를 생성
  - c => s : 암호화 준비가 되었다
  - s => c : 암호화 준비가 되었다
  - 암호화 통신 시작
- 상호 인증 장치가 있지만, 불특정 다수가 access 하는 웹 사이트의 TLS 에서는 클라이언트 인증은 하지 않는다고 함

# 코드 서명
- 배포할 프로그램 코드 (보안 패치 등의 업데이트 프로그램)에 대한 서명
- 해당 프로그램이 정당하다는 것을 증명하기 위해 코드 서명을 붙임
- 코드 서명의 베이스가 되는 것은 전자서명 기술
  - 데이터가 원본이라는 것을 보증
  - 누가 서명했는지를 보증

# 전자 서명 Vs. 공개키 암호 방식
- 전자 서명 : 특정한 사람만 서명(비밀키로 암호화)을 할 수 있음 / 누구나 그 서명을 검증(공개키로 복호화)할 수 있음
  - 전자 서명은 공개키 암호 방식의 성질을 반대로 한 것

